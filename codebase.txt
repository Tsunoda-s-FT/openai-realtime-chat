└── src
    ├── app
        ├── api
        │   └── token
        │   │   └── route.js
        ├── layout.js
        └── page.js
    ├── components
        ├── Layout.jsx
        ├── chat
        │   ├── ChatBubble.jsx
        │   ├── ChatContainer.jsx
        │   ├── ChatHeader.jsx
        │   ├── ChatInput.jsx
        │   └── SessionController.jsx
        └── ui
        │   ├── Button.jsx
        │   ├── StatusIndicator.jsx
        │   └── TextInput.jsx
    ├── hooks
        └── useRealtime.js
    └── styles
        ├── globals.css
        └── variables.css


/src/app/api/token/route.js:
--------------------------------------------------------------------------------
 1 | import { NextResponse } from 'next/server';
 2 | import path from 'path';
 3 | import fs from 'fs';
 4 | 
 5 | // AIインストラクション設定を読み込む
 6 | const instructionsPath = path.join(process.cwd(), 'config', 'instructions.json');
 7 | const instructionsConfig = JSON.parse(
 8 |   fs.readFileSync(instructionsPath, 'utf-8')
 9 | );
10 | 
11 | export async function GET() {
12 |   try {
13 |     const response = await fetch(
14 |       "https://api.openai.com/v1/realtime/sessions",
15 |       {
16 |         method: "POST",
17 |         headers: {
18 |           Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
19 |           "Content-Type": "application/json",
20 |         },
21 |         body: JSON.stringify({
22 |           model: "gpt-4o-realtime-preview-2024-12-17",
23 |           voice: "shimmer",
24 |           instructions: instructionsConfig.instructions,
25 |         }),
26 |       },
27 |     );
28 | 
29 |     if (!response.ok) {
30 |       throw new Error(`OpenAI API error: ${response.status}`);
31 |     }
32 | 
33 |     const data = await response.json();
34 |     return NextResponse.json(data);
35 |   } catch (error) {
36 |     console.error("Token generation error:", error);
37 |     return NextResponse.json({ error: "Failed to generate token" }, { status: 500 });
38 |   }
39 | }


--------------------------------------------------------------------------------
/src/app/layout.js:
--------------------------------------------------------------------------------
 1 | import '@/styles/globals.css';
 2 | 
 3 | export const metadata = {
 4 |   title: 'カフェのシチュエーション',
 5 |   description: 'OpenAI Realtime Console',
 6 |   viewport: 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no',
 7 |   themeColor: '#ffffff',
 8 |   icons: {
 9 |     icon: '/assets/openai-logomark.svg',
10 |   },
11 | };
12 | 
13 | export default function RootLayout({ children }) {
14 |   return (
15 |     <html lang="ja">
16 |       <body>{children}</body>
17 |     </html>
18 |   );
19 | }


--------------------------------------------------------------------------------
/src/app/page.js:
--------------------------------------------------------------------------------
 1 | 'use client';
 2 | 
 3 | import React from "react";
 4 | import Layout from "@/components/Layout";
 5 | import ChatHeader from "@/components/chat/ChatHeader";
 6 | import ChatContainer from "@/components/chat/ChatContainer";
 7 | import SessionController from "@/components/chat/SessionController";
 8 | import useRealtime from "@/hooks/useRealtime";
 9 | 
10 | /**
11 |  * チャットページコンポーネント
12 |  */
13 | export default function ChatPage() {
14 |   const {
15 |     isSessionActive,
16 |     messages,
17 |     status,
18 |     startSession,
19 |     stopSession,
20 |     sendTextMessage
21 |   } = useRealtime();
22 | 
23 |   return (
24 |     <Layout
25 |       header={<ChatHeader />}
26 |     >
27 |       {/* チャットコンテナ */}
28 |       <ChatContainer 
29 |         messages={messages} 
30 |         status={status} 
31 |       />
32 |       
33 |       {/* 入力コントロールエリア */}
34 |       <div className="fixed-container bottom-0 py-4 px-5 mb-2 mx-2 border border-slate-200 rounded-xl bg-white shadow-sm safe-bottom">
35 |         <SessionController
36 |           isSessionActive={isSessionActive}
37 |           status={status}
38 |           startSession={startSession}
39 |           stopSession={stopSession}
40 |           sendTextMessage={sendTextMessage}
41 |         />
42 |       </div>
43 |     </Layout>
44 |   );
45 | }


--------------------------------------------------------------------------------
/src/components/Layout.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | 
 3 | /**
 4 |  * 全体レイアウトコンポーネント
 5 |  */
 6 | export default function Layout({ children, header }) {
 7 |   return (
 8 |     <div className="h-full flex flex-col bg-slate-50 relative">
 9 |       
10 |       <main className="h-full pt-14">
11 |         {children}
12 |       </main>
13 |     </div>
14 |   );
15 | }


--------------------------------------------------------------------------------
/src/components/chat/ChatBubble.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | 
 3 | /**
 4 |  * チャットメッセージの吹き出しコンポーネント
 5 |  */
 6 | export default function ChatBubble({ message }) {
 7 |   const isUser = message.role === "user";
 8 |   
 9 |   return (
10 |     <div className={`flex ${isUser ? "justify-end" : "justify-start"} mb-3`}>
11 |       <div
12 |         className={`
13 |           max-w-[85%] px-4 py-3 
14 |           ${isUser 
15 |             ? "bg-blue-50 text-slate-800 rounded-2xl rounded-br-sm" 
16 |             : "bg-white text-slate-800 rounded-2xl rounded-bl-sm border border-slate-200"
17 |           }
18 |         `}
19 |       >
20 |         <div className="whitespace-pre-wrap">{message.content}</div>
21 |         
22 |         {!isUser && (
23 |           <div className="mt-1 text-xs text-slate-400 italic">
24 |             文字起こし完了
25 |           </div>
26 |         )}
27 |       </div>
28 |     </div>
29 |   );
30 | }


--------------------------------------------------------------------------------
/src/components/chat/ChatContainer.jsx:
--------------------------------------------------------------------------------
 1 | import React, { useRef, useEffect } from "react";
 2 | import { MessageCircle } from "react-feather";
 3 | import ChatBubble from "./ChatBubble";
 4 | import StatusIndicator from "../ui/StatusIndicator";
 5 | 
 6 | /**
 7 |  * チャットメッセージと状態を表示するコンテナ
 8 |  */
 9 | export default function ChatContainer({ messages, status }) {
10 |   const containerRef = useRef(null);
11 | 
12 |   // 新しいメッセージが来たら自動スクロール
13 |   useEffect(() => {
14 |     if (containerRef.current) {
15 |       containerRef.current.scrollTop = containerRef.current.scrollHeight;
16 |     }
17 |   }, [messages, status]);
18 | 
19 |   return (
20 |     <div 
21 |       ref={containerRef}
22 |       className="chat-area-container px-4 py-4"
23 |     >
24 |       {messages.length === 0 ? (
25 |         // メッセージがない場合のプレースホルダー
26 |         <div className="flex flex-col items-center justify-center h-full text-slate-500">
27 |           <MessageCircle size={36} className="mb-3 text-slate-300" />
28 |           <p className="text-center">会話を開始してください</p>
29 |           <StatusIndicator status={status} />
30 |         </div>
31 |       ) : (
32 |         // メッセージリスト
33 |         <div className="flex flex-col">
34 |           {messages.map((message, index) => (
35 |             <ChatBubble 
36 |               key={`${message.item_id || index}-${message.timestamp || Date.now()}`}
37 |               message={message} 
38 |             />
39 |           ))}
40 |           
41 |           {/* 現在のステータス表示 */}
42 |           <StatusIndicator status={status} />
43 |         </div>
44 |       )}
45 |     </div>
46 |   );
47 | }


--------------------------------------------------------------------------------
/src/components/chat/ChatHeader.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | import Image from "next/image";
 3 | 
 4 | /**
 5 |  * チャットヘッダーコンポーネント
 6 |  */
 7 | export default function ChatHeader({ title = "カフェのシチュエーション" }) {
 8 |   return (
 9 |     <header className="fixed-container top-0 h-14 flex items-center border-b border-slate-200 bg-white shadow-sm">
10 |       <div className="flex items-center gap-3 px-4 w-full">
11 |         <Image 
12 |           src="/assets/openai-logomark.svg" 
13 |           alt="OpenAI Logo" 
14 |           width={24} 
15 |           height={24} 
16 |         />
17 |         <h1 className="text-lg font-medium text-slate-800 truncate">
18 |           {title}
19 |         </h1>
20 |       </div>
21 |     </header>
22 |   );
23 | }


--------------------------------------------------------------------------------
/src/components/chat/ChatInput.jsx:
--------------------------------------------------------------------------------
 1 | import React, { useState, useRef } from "react";
 2 | import { Send } from "react-feather";
 3 | import TextInput from "../ui/TextInput";
 4 | import Button from "../ui/Button";
 5 | 
 6 | /**
 7 |  * チャットの入力フィールドコンポーネント
 8 |  */
 9 | export default function ChatInput({ onSendMessage, disabled = false }) {
10 |   const [message, setMessage] = useState("");
11 |   const inputRef = useRef(null);
12 | 
13 |   function handleSendMessage() {
14 |     if (message.trim() && !disabled) {
15 |       onSendMessage(message);
16 |       setMessage("");
17 |       if (inputRef.current) {
18 |         inputRef.current.focus();
19 |       }
20 |     }
21 |   }
22 | 
23 |   return (
24 |     <div className="flex items-center gap-2 w-full">
25 |       <TextInput
26 |         ref={inputRef}
27 |         value={message}
28 |         onChange={(e) => setMessage(e.target.value)}
29 |         placeholder="メッセージを入力..."
30 |         disabled={disabled}
31 |         onKeyDown={(e) => {
32 |           if (e.key === "Enter" && !e.shiftKey && message.trim() && !disabled) {
33 |             e.preventDefault();
34 |             handleSendMessage();
35 |           }
36 |         }}
37 |       />
38 |       
39 |       <Button
40 |         onClick={handleSendMessage}
41 |         variant="primary"
42 |         size="icon"
43 |         disabled={!message.trim() || disabled}
44 |         icon={<Send />}
45 |         aria-label="送信"
46 |       />
47 |     </div>
48 |   );
49 | }


--------------------------------------------------------------------------------
/src/components/chat/SessionController.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | import { CloudOff, Play, MessageCircle } from "react-feather";
 3 | import Button from "../ui/Button";
 4 | import ChatInput from "./ChatInput";
 5 | 
 6 | /**
 7 |  * セッションコントロールコンポーネント
 8 |  * セッションの開始・終了や入力コントロールを管理
 9 |  */
10 | export default function SessionController({
11 |   isSessionActive,
12 |   status,
13 |   startSession,
14 |   stopSession,
15 |   sendTextMessage
16 | }) {
17 |   const isBusy = status === "sending" || status === "listening" || status === "connecting";
18 |   
19 |   // セッション未開始時
20 |   if (!isSessionActive) {
21 |     return (
22 |       <div className="flex justify-center w-full">
23 |         <Button
24 |           onClick={startSession}
25 |           variant={status === "connecting" ? "secondary" : "primary"}
26 |           disabled={status === "connecting"}
27 |           icon={status === "connecting" ? <MessageCircle className="animate-pulse" /> : <Play />}
28 |         >
29 |           {status === "connecting" ? "接続中..." : "会話を開始"}
30 |         </Button>
31 |       </div>
32 |     );
33 |   }
34 |   
35 |   // セッション開始時
36 |   return (
37 |     <div className="flex items-center w-full gap-2">
38 |       <div className="flex-1">
39 |         <ChatInput 
40 |           onSendMessage={sendTextMessage} 
41 |           disabled={isBusy}
42 |         />
43 |       </div>
44 |       
45 |       <Button 
46 |         onClick={stopSession} 
47 |         variant="secondary"
48 |         size="icon"
49 |         icon={<CloudOff />}
50 |         aria-label="切断"
51 |       />
52 |     </div>
53 |   );
54 | }


--------------------------------------------------------------------------------
/src/components/ui/Button.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | 
 3 | /**
 4 |  * 汎用ボタンコンポーネント
 5 |  */
 6 | export default function Button({ 
 7 |   children, 
 8 |   icon, 
 9 |   onClick, 
10 |   variant = "primary", 
11 |   size = "default",
12 |   disabled = false,
13 |   fullWidth = false, 
14 |   className = "",
15 |   ...props
16 | }) {
17 |   const baseClasses = "inline-flex items-center justify-center font-medium rounded-full transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2";
18 |   
19 |   // バリアント別スタイル
20 |   const variantClasses = {
21 |     primary: "bg-blue-500 hover:bg-blue-600 text-white focus:ring-blue-500",
22 |     secondary: "bg-slate-600 hover:bg-slate-700 text-white focus:ring-slate-500",
23 |     danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
24 |     ghost: "bg-transparent hover:bg-slate-100 text-slate-700 focus:ring-slate-500"
25 |   };
26 |   
27 |   // サイズ別スタイル
28 |   const sizeClasses = {
29 |     sm: "text-sm px-3 py-1.5 gap-1.5",
30 |     default: "text-base px-4 py-2.5 gap-2",
31 |     lg: "text-lg px-5 py-3 gap-3",
32 |     icon: "p-2.5" // アイコンのみ
33 |   };
34 |   
35 |   const disabledClasses = disabled 
36 |     ? "opacity-50 cursor-not-allowed pointer-events-none" 
37 |     : "";
38 |   
39 |   const widthClasses = fullWidth ? "w-full" : "";
40 |   
41 |   const combinedClasses = `
42 |     ${baseClasses}
43 |     ${variantClasses[variant] || variantClasses.primary}
44 |     ${sizeClasses[size] || sizeClasses.default}
45 |     ${disabledClasses}
46 |     ${widthClasses}
47 |     ${className}
48 |   `;
49 | 
50 |   return (
51 |     <button
52 |       className={combinedClasses.trim()}
53 |       onClick={onClick}
54 |       disabled={disabled}
55 |       type="button"
56 |       {...props}
57 |     >
58 |       {icon && <span className={children ? "flex-shrink-0" : ""}>{icon}</span>}
59 |       {children && <span>{children}</span>}
60 |     </button>
61 |   );
62 | }


--------------------------------------------------------------------------------
/src/components/ui/StatusIndicator.jsx:
--------------------------------------------------------------------------------
 1 | import React from "react";
 2 | import { MessageCircle, Mic, Send, AlertCircle } from "react-feather";
 3 | 
 4 | // ステータスメッセージとアイコンのマッピング
 5 | const statusConfig = {
 6 |   idle: { 
 7 |     message: null, 
 8 |     icon: null 
 9 |   },
10 |   connecting: { 
11 |     message: "接続しています...", 
12 |     icon: <MessageCircle className="animate-pulse" size={16} />, 
13 |     color: "text-blue-500" 
14 |   },
15 |   connected: { 
16 |     message: "接続しました", 
17 |     icon: <MessageCircle size={16} />, 
18 |     color: "text-green-500" 
19 |   },
20 |   listening: { 
21 |     message: "聞き取り中... 🎤", 
22 |     icon: <Mic className="animate-pulse" size={16} />, 
23 |     color: "text-purple-500" 
24 |   },
25 |   sending: { 
26 |     message: "送信中... ⏳", 
27 |     icon: <Send className="animate-pulse" size={16} />, 
28 |     color: "text-blue-500" 
29 |   },
30 |   responding: { 
31 |     message: "返答中... 💬", 
32 |     icon: <MessageCircle className="animate-pulse" size={16} />, 
33 |     color: "text-green-500" 
34 |   },
35 |   error: { 
36 |     message: "エラーが発生しました ❌", 
37 |     icon: <AlertCircle size={16} />, 
38 |     color: "text-red-500" 
39 |   }
40 | };
41 | 
42 | /**
43 |  * 現在のステータスを表示するコンポーネント
44 |  */
45 | export default function StatusIndicator({ status }) {
46 |   const currentStatus = statusConfig[status] || statusConfig.idle;
47 |   
48 |   if (!currentStatus.message) return null;
49 |   
50 |   return (
51 |     <div className={`
52 |       flex items-center justify-center gap-2 
53 |       py-2 px-3 my-3 mx-auto
54 |       rounded-full bg-slate-100 text-sm
55 |       ${currentStatus.color || ""}
56 |     `}>
57 |       {currentStatus.icon}
58 |       <span>{currentStatus.message}</span>
59 |     </div>
60 |   );
61 | }


--------------------------------------------------------------------------------
/src/components/ui/TextInput.jsx:
--------------------------------------------------------------------------------
 1 | import React, { forwardRef } from "react";
 2 | 
 3 | /**
 4 |  * テキスト入力フィールドコンポーネント
 5 |  */
 6 | const TextInput = forwardRef(({ 
 7 |   value, 
 8 |   onChange, 
 9 |   placeholder = "", 
10 |   disabled = false, 
11 |   onKeyDown,
12 |   className = "",
13 |   ...props 
14 | }, ref) => {
15 |   return (
16 |     <input
17 |       ref={ref}
18 |       type="text"
19 |       className={`
20 |         w-full px-4 py-3 
21 |         border border-slate-300 rounded-full 
22 |         text-slate-800 placeholder-slate-400
23 |         focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500
24 |         disabled:opacity-60 disabled:bg-slate-50
25 |         ${className}
26 |       `}
27 |       value={value}
28 |       onChange={onChange}
29 |       placeholder={placeholder}
30 |       disabled={disabled}
31 |       onKeyDown={onKeyDown}
32 |       {...props}
33 |     />
34 |   );
35 | });
36 | 
37 | TextInput.displayName = "TextInput";
38 | 
39 | export default TextInput;


--------------------------------------------------------------------------------
/src/hooks/useRealtime.js:
--------------------------------------------------------------------------------
  1 | import { useState, useRef, useEffect } from "react";
  2 | 
  3 | /**
  4 |  * OpenAI Realtime API との WebRTC 接続を管理するカスタムフック
  5 |  */
  6 | export default function useRealtime() {
  7 |   const [isSessionActive, setIsSessionActive] = useState(false);
  8 |   const [events, setEvents] = useState([]);
  9 |   const [messages, setMessages] = useState([]);
 10 |   const [status, setStatus] = useState("idle");
 11 |   const [dataChannel, setDataChannel] = useState(null);
 12 |   const peerConnection = useRef(null);
 13 |   const audioElement = useRef(null);
 14 | 
 15 |   // セッション開始
 16 |   async function startSession() {
 17 |     setStatus("connecting");
 18 |     try {
 19 |       // サーバーからの一時的なトークンを取得
 20 |       const tokenResponse = await fetch("/api/token");
 21 |       const data = await tokenResponse.json();
 22 |       const EPHEMERAL_KEY = data.client_secret.value;
 23 | 
 24 |       // WebRTC ピア接続の作成
 25 |       const pc = new RTCPeerConnection();
 26 | 
 27 |       // AIからの音声を再生するためのオーディオ要素を設定
 28 |       audioElement.current = document.createElement("audio");
 29 |       audioElement.current.autoplay = true;
 30 |       pc.ontrack = (e) => (audioElement.current.srcObject = e.streams[0]);
 31 | 
 32 |       // マイク入力用のローカルオーディオトラックを追加
 33 |       try {
 34 |         const ms = await navigator.mediaDevices.getUserMedia({
 35 |           audio: true,
 36 |         });
 37 |         pc.addTrack(ms.getTracks()[0]);
 38 |       } catch (error) {
 39 |         console.error("マイクへのアクセスエラー:", error);
 40 |         setStatus("error");
 41 |         return;
 42 |       }
 43 | 
 44 |       // イベント送受信用のデータチャネルを設定
 45 |       const dc = pc.createDataChannel("oai-events");
 46 |       setDataChannel(dc);
 47 | 
 48 |       // SDP を使用してセッションを開始
 49 |       const offer = await pc.createOffer();
 50 |       await pc.setLocalDescription(offer);
 51 | 
 52 |       const baseUrl = "https://api.openai.com/v1/realtime";
 53 |       const model = "gpt-4o-realtime-preview-2024-12-17";
 54 |       const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
 55 |         method: "POST",
 56 |         body: offer.sdp,
 57 |         headers: {
 58 |           Authorization: `Bearer ${EPHEMERAL_KEY}`,
 59 |           "Content-Type": "application/sdp",
 60 |         },
 61 |       });
 62 | 
 63 |       if (!sdpResponse.ok) {
 64 |         throw new Error(`サーバーエラー: ${sdpResponse.status}`);
 65 |       }
 66 | 
 67 |       const answer = {
 68 |         type: "answer",
 69 |         sdp: await sdpResponse.text(),
 70 |       };
 71 |       await pc.setRemoteDescription(answer);
 72 | 
 73 |       peerConnection.current = pc;
 74 |     } catch (error) {
 75 |       console.error("接続エラー:", error);
 76 |       setStatus("error");
 77 |     }
 78 |   }
 79 | 
 80 |   // セッションの停止とクリーンアップ
 81 |   function stopSession() {
 82 |     if (dataChannel) {
 83 |       dataChannel.close();
 84 |     }
 85 | 
 86 |     if (peerConnection.current) {
 87 |       peerConnection.current.getSenders().forEach((sender) => {
 88 |         if (sender.track) {
 89 |           sender.track.stop();
 90 |         }
 91 |       });
 92 |       peerConnection.current.close();
 93 |     }
 94 | 
 95 |     setIsSessionActive(false);
 96 |     setDataChannel(null);
 97 |     peerConnection.current = null;
 98 |     setStatus("idle");
 99 |     setMessages([]);
100 |   }
101 | 
102 |   // モデルにイベントを送信
103 |   function sendClientEvent(message) {
104 |     if (dataChannel) {
105 |       message.event_id = message.event_id || crypto.randomUUID();
106 |       dataChannel.send(JSON.stringify(message));
107 |       setEvents((prev) => [message, ...prev]);
108 |     } else {
109 |       console.error("データチャネルがありません", message);
110 |     }
111 |   }
112 | 
113 |   // テキストメッセージを送信
114 |   function sendTextMessage(message) {
115 |     // ローカル状態をすぐに更新
116 |     setMessages(prev => [...prev, { role: "user", content: message, timestamp: Date.now() }]);
117 |     
118 |     const event = {
119 |       type: "conversation.item.create",
120 |       item: {
121 |         type: "message",
122 |         role: "user",
123 |         content: [
124 |           {
125 |             type: "input_text",
126 |             text: message,
127 |           },
128 |         ],
129 |       },
130 |     };
131 | 
132 |     setStatus("sending");
133 |     sendClientEvent(event);
134 |     sendClientEvent({ type: "response.create" });
135 |   }
136 | 
137 |   // データチャネルのイベントリスナーを設定
138 |   useEffect(() => {
139 |     if (!dataChannel) return;
140 |     
141 |     const handleMessage = (e) => {
142 |       try {
143 |         const eventData = JSON.parse(e.data);
144 |         console.log("RECEIVED EVENT:", eventData.type, eventData);
145 |         
146 |         // 特定のイベントを直接処理
147 |         if (eventData.type === "response.audio_transcript.done") {
148 |           console.log("***** 文字起こし完了イベント受信 *****", eventData.transcript);
149 |           
150 |           if (eventData.transcript && eventData.item_id) {
151 |             setMessages(prev => {
152 |               // 新しいメッセージを作成
153 |               const newMessage = {
154 |                 role: "assistant",
155 |                 content: eventData.transcript,
156 |                 item_id: eventData.item_id,
157 |                 timestamp: Date.now()
158 |               };
159 |               
160 |               // 既存のメッセージを探索
161 |               const existingIndex = prev.findIndex(m => m.item_id === eventData.item_id);
162 |               
163 |               if (existingIndex >= 0) {
164 |                 // 既存のメッセージを更新
165 |                 const updatedMessages = [...prev];
166 |                 updatedMessages[existingIndex] = newMessage;
167 |                 return updatedMessages;
168 |               } else {
169 |                 // 新しいメッセージとして追加
170 |                 return [...prev, newMessage];
171 |               }
172 |             });
173 |           }
174 |         }
175 |         
176 |         // バックアップとして content_part.done も処理
177 |         else if (eventData.type === "response.content_part.done" && 
178 |                  eventData.part?.type === "audio" && 
179 |                  eventData.part?.transcript) {
180 |           console.log("***** コンテンツパート完了イベント受信 *****", eventData.part.transcript);
181 |           
182 |           if (eventData.part.transcript && eventData.item_id) {
183 |             setMessages(prev => {
184 |               // 既存のメッセージを探索
185 |               const existingIndex = prev.findIndex(m => m.item_id === eventData.item_id);
186 |               
187 |               // 新しいメッセージを作成
188 |               const newMessage = {
189 |                 role: "assistant",
190 |                 content: eventData.part.transcript,
191 |                 item_id: eventData.item_id,
192 |                 timestamp: Date.now()
193 |               };
194 |               
195 |               if (existingIndex >= 0) {
196 |                 // 既存のメッセージを更新
197 |                 const updatedMessages = [...prev];
198 |                 updatedMessages[existingIndex] = newMessage;
199 |                 return updatedMessages;
200 |               } else {
201 |                 // 新しいメッセージとして追加
202 |                 return [...prev, newMessage];
203 |               }
204 |             });
205 |           }
206 |         }
207 |         
208 |         // ユーザーメッセージの処理
209 |         else if (eventData.type === "conversation.item.created" && 
210 |                  eventData.item?.role === "user" && 
211 |                  eventData.item?.content) {
212 |           
213 |           const userContent = eventData.item.content;
214 |           let userText = "";
215 |           
216 |           if (Array.isArray(userContent)) {
217 |             userText = userContent
218 |               .filter(part => part.type === "text" || part.type === "user_message" || part.type === "input_text")
219 |               .map(part => part.text || "")
220 |               .join("");
221 |           }
222 |           
223 |           if (userText) {
224 |             setMessages(prev => {
225 |               // 直近のユーザーメッセージと重複しないようにチェック
226 |               if (prev.length > 0 && 
227 |                   prev[prev.length - 1].role === "user" && 
228 |                   prev[prev.length - 1].content === userText) {
229 |                 return prev;
230 |               }
231 |               
232 |               return [...prev, { 
233 |                 role: "user", 
234 |                 content: userText,
235 |                 item_id: eventData.item.id,
236 |                 timestamp: Date.now()
237 |               }];
238 |             });
239 |           }
240 |         }
241 |         
242 |         // 状態の更新
243 |         if (eventData.type === "input_audio_buffer.speech_started") {
244 |           setStatus("listening");
245 |         } else if (eventData.type === "response.content_part.added") {
246 |           setStatus("responding");
247 |         } else if (eventData.type === "response.done") {
248 |           setStatus("idle");
249 |         }
250 |         
251 |         // イベントリストに追加
252 |         setEvents((prev) => [eventData, ...prev]);
253 |       } catch (error) {
254 |         console.error("イベントデータの解析エラー:", error);
255 |       }
256 |     };
257 |     
258 |     const handleOpen = () => {
259 |       console.log("データチャネルが開かれました");
260 |       setIsSessionActive(true);
261 |       setEvents([]);
262 |       setStatus("connected");
263 |     };
264 |     
265 |     const handleClose = () => {
266 |       console.log("データチャネルが閉じられました");
267 |       setIsSessionActive(false);
268 |       setStatus("idle");
269 |     };
270 |     
271 |     const handleError = (error) => {
272 |       console.error("データチャネルエラー:", error);
273 |       setStatus("error");
274 |     };
275 |     
276 |     // イベントリスナーの追加
277 |     dataChannel.addEventListener("message", handleMessage);
278 |     dataChannel.addEventListener("open", handleOpen);
279 |     dataChannel.addEventListener("close", handleClose);
280 |     dataChannel.addEventListener("error", handleError);
281 |     
282 |     // アンマウント時のイベントリスナーのクリーンアップ
283 |     return () => {
284 |       dataChannel.removeEventListener("message", handleMessage);
285 |       dataChannel.removeEventListener("open", handleOpen);
286 |       dataChannel.removeEventListener("close", handleClose);
287 |       dataChannel.removeEventListener("error", handleError);
288 |     };
289 |   }, [dataChannel]);
290 | 
291 |   return {
292 |     isSessionActive,
293 |     messages,
294 |     status,
295 |     events,
296 |     startSession,
297 |     stopSession,
298 |     sendTextMessage
299 |   };
300 | }


--------------------------------------------------------------------------------
/src/styles/globals.css:
--------------------------------------------------------------------------------
 1 | @import './variables.css';
 2 | @tailwind base;
 3 | @tailwind components;
 4 | @tailwind utilities;
 5 | 
 6 | html,
 7 | body {
 8 |   height: 100%;
 9 |   width: 100%;
10 |   margin: 0;
11 |   padding: 0;
12 |   font-family: var(--font-base);
13 |   font-size: var(--font-size-base);
14 |   color: var(--color-text-primary);
15 |   background-color: var(--color-background);
16 |   -webkit-tap-highlight-color: transparent;
17 |   overflow: hidden;
18 | }
19 | 
20 | #root {
21 |   height: 100%;
22 |   width: 100%;
23 | }
24 | 
25 | /* モバイルでの入力フィールドのズーム防止 */
26 | input, button {
27 |   font-size: 16px;
28 | }
29 | 
30 | /* アニメーション */
31 | @keyframes pulse {
32 |   0% { opacity: 0.6; }
33 |   50% { opacity: 1; }
34 |   100% { opacity: 0.6; }
35 | }
36 | 
37 | .animate-pulse {
38 |   animation: pulse 1.5s ease-in-out infinite;
39 | }
40 | 
41 | /* スクロールバースタイル */
42 | ::-webkit-scrollbar {
43 |   width: 6px;
44 | }
45 | 
46 | ::-webkit-scrollbar-track {
47 |   background: var(--color-background-alt);
48 | }
49 | 
50 | ::-webkit-scrollbar-thumb {
51 |   background: var(--color-secondary-light);
52 |   border-radius: 3px;
53 | }
54 | 
55 | ::-webkit-scrollbar-thumb:hover {
56 |   background: var(--color-secondary);
57 | }
58 | 
59 | /* ユーティリティクラス */
60 | .safe-bottom {
61 |   padding-bottom: env(safe-area-inset-bottom, 0);
62 | }
63 | 
64 | .fixed-container {
65 |   position: fixed;
66 |   left: 0;
67 |   right: 0;
68 |   z-index: 10;
69 |   background-color: var(--color-surface);
70 | }
71 | 
72 | .chat-area-container {
73 |   height: calc(100% - var(--header-height) - var(--input-bar-height) - 1rem);
74 |   padding-bottom: 1.5rem;
75 |   overflow-y: auto;
76 |   scrollbar-width: thin;
77 |   scrollbar-color: var(--color-secondary-light) var(--color-background-alt);
78 | }


--------------------------------------------------------------------------------
/src/styles/variables.css:
--------------------------------------------------------------------------------
 1 | :root {
 2 |     /* カラーパレット */
 3 |     --color-primary: #3b82f6;
 4 |     --color-primary-dark: #2563eb;
 5 |     --color-primary-light: #93c5fd;
 6 |     --color-secondary: #64748b;
 7 |     --color-secondary-dark: #475569;
 8 |     --color-secondary-light: #94a3b8;
 9 |     --color-danger: #ef4444;
10 |     --color-danger-dark: #dc2626;
11 |     --color-success: #10b981;
12 |     --color-warning: #f59e0b;
13 |     --color-info: #3b82f6;
14 |   
15 |     /* 背景色 */
16 |     --color-background: #f8fafc;
17 |     --color-background-alt: #f1f5f9;
18 |     
19 |     /* コンテンツ背景 */
20 |     --color-surface: #ffffff;
21 |     --color-user-bubble: #e1f5fe;
22 |     --color-ai-bubble: #f5f7f9;
23 |     
24 |     /* テキスト色 */
25 |     --color-text-primary: #1e293b;
26 |     --color-text-secondary: #64748b;
27 |     --color-text-placeholder: #94a3b8;
28 |     --color-text-disabled: #cbd5e1;
29 |     --color-text-link: #2563eb;
30 |     --color-text-light: #f8fafc;
31 |     
32 |     /* ボーダー */
33 |     --color-border: #e2e8f0;
34 |     --color-border-light: #f1f5f9;
35 |     --color-border-focus: #3b82f6;
36 |     
37 |     /* フォント */
38 |     --font-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
39 |     --font-size-xs: 0.75rem;   /* 12px */
40 |     --font-size-sm: 0.875rem;  /* 14px */
41 |     --font-size-base: 1rem;    /* 16px */
42 |     --font-size-lg: 1.125rem;  /* 18px */
43 |     --font-size-xl: 1.25rem;   /* 20px */
44 |     
45 |     /* スペーシング */
46 |     --spacing-xs: 0.25rem;     /* 4px */
47 |     --spacing-sm: 0.5rem;      /* 8px */
48 |     --spacing-md: 1rem;        /* 16px */
49 |     --spacing-lg: 1.5rem;      /* 24px */
50 |     --spacing-xl: 2rem;        /* 32px */
51 |     
52 |     /* その他 */
53 |     --border-radius-sm: 0.25rem;     /* 4px */
54 |     --border-radius-md: 0.5rem;      /* 8px */
55 |     --border-radius-lg: 0.75rem;     /* 12px */
56 |     --border-radius-xl: 1rem;        /* 16px */
57 |     --border-radius-full: 9999px;
58 |     
59 |     /* レイアウト */
60 |     --header-height: 3.5rem;           /* 56px */
61 |     --input-bar-height: 4.5rem;        /* 72px */
62 |     --chat-max-width: 48rem;           /* 768px */
63 |   }


--------------------------------------------------------------------------------